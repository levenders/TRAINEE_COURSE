// Домашнее задание(Порешать типовые задачи - написать порядок и вывод в консоли):
// 1)
console.log('1')
setTimeout(() => console.log('2'), 1)
let promiseNew = new Promise((resolve) => {
  console.log('3')
  resolve()
})
promiseNew.then(() => console.log('4'))
setTimeout(() => console.log('5'))
console.log('6')
// description:
/*
1. вывод: 1. Синхронный код попадает в стек и сразу исполняется
Далее setTimeout попадет в стек и далее регистрируется в web Api
2. вывод: 3. Синхронный код попадает в стек и сразу исполняется
Далее promiseNew.resolve().then попадет в стек и далее в очередь микрозадач
Далее setTimeout попадет в стек и далее регистрируется в web Api
3. вывод: 6. Синхронный код попадает в стек и сразу исполняется
4. вывод: 4. Освобождается очередь микрозадач, а именно выполняется промис
5. вывод: 5. Поскольку у второго setTimeouta время не указано, то это условный ноль и он первее попадет в очередь макрозадач и исполнится после завершения очереди микрозадач
6. вывод: 2. после истечений 1мс сет таймаут попадет в очередь макрозадач и посколько очередь микрозадач пуста, то он выполняется

Итоговый ответ: 1 3 6 4 5 2

НО реализация Eventloop в ноде и в браузере отличаются, поэтому последниие выводы с сет интервалами отрабатывают по разному. В браузере будет как указал я, а в ноде будет наоборот, т.е. 2 и затем 5
*/

//////////////////////////////
// 2)
let promiseTree = new Promise((resolve, reject) => {
  resolve('a')
  console.log('1')
  setTimeout(() => {
    console.log('2')
  }, 0)
  console.log('3')
})
// description:
/*
1. вывод: 1. Синхронный код попадает в стек и сразу исполняется
2. вывод: 3. Синхронный код попадает в стек и сразу исполняется
3. вывод: 2. Сет таймаут попадет в стек из него регистрируется в web Api, после условного нуля времени попадает в очередь макрозадач и поскольку очередь микрозадач пуста - выполняется

Итоговый ответ: 1 3 2

*/

/////////////////////////
// 3)
let promiseTwo = new Promise((resolve, reject) => {
  resolve('a')
})
promiseTwo
  .then((res) => {
    return res + 'b'
  })
  .then((res) => {
    return res + 'с'
  })
  .finally((res) => {
    return res + '!!!!!!!'
  })
  .catch((res) => {
    return res + 'd'
  })
  .then((res) => {
    console.log(res)
  })

// description:
/*
1 then с результатом resolve('a'). возвращает: 'ab'. 
2 then с результатом resolve('ab'). возвращает: 'abc'.
3. finally имеет особеннось, он ничего не принимает и не возращает, следовательно игнорируем ретерн
4. catch тоже игнорируем, тк промис не режектился 
5. then отрабатывает с резульатом ('abc') и выводит в консоль

Итоговый ответ: 'abc'

*/

/////////////////////////////
// 4)
function doSmth() {
  return Promise.resolve('123')
}
doSmth()
  .then(function (a) {
    console.log('1', a) //
    return a
  })
  .then(function (b) {
    console.log('2', b)
    return Promise.reject('321')
  })
  .catch(function (err) {
    console.log('3', err)
  })
  .then(function (c) {
    console.log('4', c)
    return c
  })
// description:
/*
1 then с результатом resolve('123'). выводит: '1' '123' и возвращает: '123'. 
2 then с результатом resolve('123'). выводит: '2' '123' и возвращает: зарежекченый промис с результатом: '321'.
3. catch отлавливает ошибку с результатом reject('321') и выводи '3' '321' и НИЧЕГО не возвращает
5. then отрабатывает с резульатом (undefined). выводит в консоль '4' undefined и ничего не возвращает

Итоговый ответ: '1' '123'   '2' '123'   '3' '321'    '4' undefined

*/

///////////////////////////
// 5)
console.log('1')
setTimeout(function () {
  console.log('2')
}, 0)
Promise.resolve().then(() => console.log('3'))
console.log('4')
// description:
/*
1. вывод: 1. Синхронный код попадает в стек и сразу исполняется
Далее setTimeout попадет в стек и из него регистрируется в web Api, и по истечению условного нуля времени попадет в очередь макрозадач
Далее promise.resolve() попадет в стек и из него попадет в очередь микрозадач
2. вывод: 4. Синхронный код попадает в стек и сразу исполняется
3. вывод: 3. Выполняется очередь микрозадач
4. вывод: 2. Поскольку очередь микрозадач пуста, выполняется макрозадача
Итоговый ответ: 1 4 3 2

*/

////////////////////////////
//7)
async function a() {
  console.log('a')
}

console.log('1')
;(async function () {
  console.log('f1')
  await a()
  console.log('f2')
})()
console.log('2')
// description:
/*
Инициализируется функция a()
1. вывод: 1. Синхронный код попадает в стек и сразу исполняется
Инициализируется и сразу выполняется самовызывающая анонимная функция. 
2. вывод: 'f1'. Синхронный код попадает в стек и сразу исполняется
Вызывается функция a() через await, что означает что оно приостанавливает выполнение функции до тех пор, пока промис не разрешится или не отклонится. 
3. вывод: 'a'. функция a() попадет в стек и сразу выполняется
Вывод в консоль после await попадат в стек и оттуда в очередь микрозадач 
4. вывод: '2'. Синхронный код попадает в стек и сразу исполняется
5. вывод: 'f2'. После выполнения синхронного кода опусташается очередь микрозадач, а в ней как раз 'f2'

Итоговый ответ: 1 f1 a 2 f2

*/

////////////////////////////////
//8)
console.log(1)

setTimeout(() => console.log(2))

async function func() {
  console.log(3)

  await new Promise((resolve) => {
    console.log(4)
    resolve()
    console.log(5)
  })
    .then(() => console.log(6))
    .then(() => console.log(7))

  console.log(8)
}

setTimeout(() => console.log(9))

func()

console.log(10)

// description:
/*
1. вывод: 1. Синхронный код попадает в стек и сразу исполняется
Далее setTimeout попадет в стек и после в webapi где по истечению условного нуля времени попадет в очередь макрозадач
Инициализируется async функция func()
Далее setTimeout попадет в стек и после в webapi где по истечению условного нуля времени попадет в очередь макрозадач
Вызывается функция func()
2. вывод: 3. Синхронный код попадает в стек и сразу исполняется
3. вывод: 4. выполняется код внутри await
Промис резолвится
4. вывод: 5. выполняется код внутри await
Первый then попадет в стек и после в очередь микрозадач
Второй then попадет в стек и после в очередь микрозадач
Вывод в консоль после await попадет в стек и после в очередь мирозадач
5. вывод: 10. Синхронный код попадает в стек и сразу исполняется
6. вывод: 6. опусташается очередь микрозадач
7. вывод: 7. опусташается очередь микрозадач
8. вывод: 8. опусташается очередь мирозадач
9. вывод: 2. Поскольку очередь микрозадач пуста - выполняется макрозадача согласно очереди
10. вывод: 9. очередь микррозадач пуста, снова выполняется макрозадача согласно очереди

Итоговый ответ: 1 3 4 5 10 6 7 8 2 9

*/

///////////////////////////////////
// 9)*
function foo(callback) {
  setTimeout(() => {
    callback('A')
  }, Math.random() * 100)
}
function bar(callback) {
  setTimeout(() => {
    callback('B')
  }, Math.random() * 100)
}
function baz(callback) {
  setTimeout(() => {
    callback('C')
  }, Math.random() * 100)
}

function syncOutput() {
  return new Promise((resolve) => foo(resolve))
    .then((result) => console.log(result))
    .then(() => new Promise((resolve) => bar(resolve)))
    .then((result) => console.log(result))
    .then(() => new Promise((resolve) => baz(resolve)))
    .then((result) => console.log(result))
}

syncOutput() // 1 вариант решения

let promisify = (func) =>
  new Promise((resolve) => {
    return func(resolve)
  })

function fooBarBaz() {
  Promise.all([promisify(foo), promisify(bar), promisify(baz)]).then((res) =>
    res.forEach((result) => console.log(result))
  )
}

fooBarBaz() // 2 вариант решения

// foo(console.log)
// bar(console.log)
// baz(console.log)

// Написать функцию, чтобы починить последовательность выполнения A,B,C без использования колбэк хэлла
// в функциях foo, bar,baz запрещено что-либо менять
// подсказка: нужны промисы =))

///////////////
// todo Объяснить код, рассказать какие консоли и в какой последовательности будут, а затем переписать его на промисы
function resolveAfter2Seconds(x) {
  console.log(`Какой Х пришёл -> ${x}`)
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(x) //
    }, 2000)
  })
}
async function add1(x) {
  console.log('add1 Hello')
  const a = await resolveAfter2Seconds(20)
  const b = await resolveAfter2Seconds(30)
  console.log('add1 Bye')
  return x + a + b
}
add1(10).then(console.log)
// description:
/*
Вызов async функции с аргументом 10. 
1. вывод:  'add1 Hello'. Синхронный код попадает в стек и сразу выполняется
Выполняется код внутри await, а именно вызов функции resolveAfter2Seconds с аргументом 20.
2. вывод: Какой Х пришёл -> 20. Синхронный код попадает в стек и сразу выполняется
Функция возвращает зарезолвленный промис но в обертке setTimeout. Он попадает в стек и после в webapi где по истечению 2 секунд времени попадет в очередь макрозадач. Посколько используется await то выполнение функции приостанавливается пока промис не зарезолвится. и спустя время указанное в setTimeout продолжается выполнение функции
3. вывод: Какой Х пришёл -> 30. Синхронный код попадает в стек и сразу выполняется
Функция возвращает зарезолвленный промис но в обертке setTimeout. Он попадает в стек и после в webapi где по истечению 2 секунд времени попадет в очередь макрозадач. Посколько используется await то выполнение функции приостанавливается пока промис не зарезолвится. и спустя время указанное в setTimeout продолжается выполнение функции
4. вывод:  'add1 Bye'. Синхронный код попадает в стек и сразу выполняется
Функция возвращает промис с резульатом 10 + 20 + 30.
5. вывод: 60. then попадает в стек, оттуда в очердь микрозадач. и покольку стек пустой - выполняется

*/

// мои вариант переписи функции на промисы:

function add1(x) {
  console.log('add1 Hello')
  return resolveAfter2Seconds(20).then((a) => {
    return resolveAfter2Seconds(30).then((b) => {
      console.log('add1 Bye')
      return x + a + b
    })
  })
}

function resolveAfter2Seconds(x) {
  console.log(`Какой Х пришёл -> ${x}`)
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(x) //
    }, 2000)
  })
}
add1(10).then(console.log)
